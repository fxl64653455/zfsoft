<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<parent>
		<groupId>com.zfsoft</groupId>
		<artifactId>zftal-boot-dependencies</artifactId>
		<version>1.0.4-SNAPSHOT</version>
		<relativePath>../zftal-boot-dependencies</relativePath>
	</parent>

	<artifactId>zftal-boot-parent</artifactId>
	<packaging>pom</packaging>
	<name>Zftal Spring Boot Parent</name>
	<description>ZFtal Projects Parent for Spring Boot</description>

	<properties>

		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>

		<!--docker build、push地址 -->
		<docker.workdir>/u01/boot/${project.artifactId}</docker.workdir>
		<docker.push.repostory>10.71.19.230:8798</docker.push.repostory>
		<docker.build.repostory>10.71.19.230</docker.build.repostory>
		<!--push镜像到私有库项目的名称 -->
		<docker.registry.name>zfsoft</docker.registry.name>

		<!--appassembler -->
		<appassembler-dir>${project.build.directory}/generated-resources/appassembler</appassembler-dir>
		<appassembler-jsw-dir>${project.build.directory}/generated-resources/appassembler/jsw</appassembler-jsw-dir>
		<appassembler-app-name>zftal-boot</appassembler-app-name>
		
		<!-- 生成API离线文参数-->
		<swagger.input>http://localhost:8080/v2/api-docs</swagger.input>
		<!-- <swagger.input>${project.basedir}/docs/swagger/swagger.json</swagger.input> -->
        <!-- <swagger.input>${project.basedir}/src/docs/swagger/swagger_petstore.yaml</swagger.input> -->
        <asciidoctor.input.directory>${generated.asciidoc.directory}</asciidoctor.input.directory>
        <asciidoctor.html.output.directory>${project.build.directory}/asciidoc/html</asciidoctor.html.output.directory>
		<asciidoctor.pdf.output.directory>${project.build.directory}/asciidoc/pdf</asciidoctor.pdf.output.directory>
        <generated.asciidoc.directory>${project.build.directory}/asciidoc</generated.asciidoc.directory>
		
		<skipTests>true</skipTests>
		
	</properties>

	<dependencies>

		<!-- Spring Boot Test 依赖 -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>

		<!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api -->
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-api</artifactId>
		</dependency>
		
		<!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api -->
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<scope>provided</scope>
		</dependency>

	</dependencies>

	<build>
		<pluginManagement>
			<plugins>
				<!-- 编译插件：编译主代码至主输出目录 -->
				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-compiler-plugin</artifactId>
					<!-- 设置源文件编码方式 -->
					<configuration>
						<defaultLibBundleDir>lib</defaultLibBundleDir>
						<!-- 源代码编译版本 -->
						<source>${java.version}</source>
						<!-- 目标平台编译版本 -->
						<target>${java.version}</target>
						<!-- 字符集编码 -->
						<encoding>${project.build.sourceEncoding}</encoding>
						<!-- -->
						<maxmem>512M</maxmem>
					</configuration>
				</plugin>
				<!-- 资源插件：复制主资源文件至主输出目录 -->
				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-resources-plugin</artifactId>
					<!-- 解决资源文件的编码问题 -->
					<configuration>
						<!-- 字符集编码 -->
						<encoding>${project.build.sourceEncoding}</encoding>
						<useDefaultDelimiters>true</useDefaultDelimiters>
					</configuration>
				</plugin>
				<!-- 单元测试插件 ：执行测试用例 -->
				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-surefire-plugin</artifactId>
					<configuration>
						<!-- 跳过单元测试 -->
						<skip>${skipTests}</skip>
						<skipTests>${skipTests}</skipTests>
						<!-- forkMode 可设置值有 “never”， “once”， “always” 和 “pertest”。 pretest： 
							每一个测试创建一个新进程，为每个测试创建新的JVM是单独测试的最彻底方式，但也是最慢的，不适合hudson上持续回归。 once：在一个进程中进行所有测试。once为默认设置，在Hudson上持续回归时建议使用默认设置。 
							always：在一个进程中并行的运行脚本，Junit4.7以上版本才可以使用，surefire的版本要在2.6以上提供这个功能，其中 threadCount：执行时，指定可分配的线程数量。只和参数parallel配合使用有效。默认：5。 -->
						<forkMode>once</forkMode>
						<argLine>-Xmx1024M -XX:MetaspaceSize=256M
							-XX:MaxMetaspaceSize=256M</argLine>
						<additionalClasspathElements>
							<additionalClasspathElement>
								${basedir}/target/test-classes
							</additionalClasspathElement>
						</additionalClasspathElements>
						<includes>
							<include>**/*Test.java</include>
						</includes>
						<excludes>
							<exclude>**/TestBean.java</exclude>
						</excludes>
					</configuration>
				</plugin>
				<!-- jar包生成插件 ：创建项目jar包 -->
				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-jar-plugin</artifactId>
					<!-- 打包jar文件时，配置manifest文件，加入lib包的jar依赖 -->
					<configuration>
						<archive>
							<manifest>
								<addClasspath>true</addClasspath>
								<classpathPrefix>lib/</classpathPrefix>
							</manifest>
						</archive>
					</configuration>
				</plugin>
				<!-- 安装插件：将项目输出构件安装到本地仓库 -->
				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-install-plugin</artifactId>
				</plugin>
				<!-- 发布插件 ：将项目输出构件部署到远程仓库 -->
				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-deploy-plugin</artifactId>
				</plugin>
				<!-- 源码插件:发布时自动将源码同时发布 -->
				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-source-plugin</artifactId>
					<!-- 打包source文件为jar文件 -->
					<configuration>
						<testFailureIgnore>true</testFailureIgnore>
						<attach>true</attach>
						<encoding>UTF-8</encoding>
					</configuration>
					<executions>
						<execution>
							<id>attach-sources</id>
							<phase>package</phase>
							<goals>
								<goal>jar-no-fork</goal>
							</goals>
						</execution>
					</executions>
				</plugin>
				<!-- 文档插件:发布时自动生成文档 -->
				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-javadoc-plugin</artifactId>
					<configuration>
						<aggregate>true</aggregate>
						<charset>UTF-8</charset>
						<encoding>UTF-8</encoding>
						<docencoding>UTF-8</docencoding>
					</configuration>
					<executions>
						<execution>
							<id>attach-javadocs</id>
							<phase>package</phase>
							<goals>
								<goal>jar</goal>
							</goals>
						</execution>
					</executions>
				</plugin>
				<!-- war 包生成插件 -->
				<plugin>
					 <groupId>org.apache.maven.plugins</groupId>
					 <artifactId>maven-war-plugin</artifactId>
					 <configuration>
					 	<!-- 包含空目录 --> 
					 	<includeEmptyDirectories>true</includeEmptyDirectories>
					 	<!-- 是否将webapp下的逻辑代码打包成jar文件，使用此可选配置参数可将已编译的类归档到一个jar文件。 并且classes 目录将被从Web应用程序排除在外，主要表现是classes目录的编译的类不会再war包中。  -->
						<archiveClasses>false</archiveClasses>
						<!-- 是否 classes目录内容（也就是WEB-INF/classes目录下的内容）可以作为一个额外的依赖附着到项目中。 打包时将war项目中相关的类文件打成独立jar包；好处是：只修改class时，可以只更新jar -->
						<attachClasses>true</attachClasses>
						<!--独立jar包后缀名称 -->
						<classesClassifier>api</classesClassifier>
					 	<!-- 设置无web.xml时不报错 --> 
					 	<failOnMissingWebXml>false</failOnMissingWebXml>
					 	<!-- 必须指定,否则默认会变成在target/war/work 导致被打包进war文件,指定后为target/work -->
						<workDirectory>${project.build.directory}/work</workDirectory>
						<!-- 指定webapp所在目录-->
						<warSourceDirectory>${basedir}/src/main/webapp</warSourceDirectory>
						<!-- 表示在打war包拷贝位于warSourceDirectory目录中的内容时要过滤的目录或文件 
						<warSourceExcludes>WEB-INF/classes/**,META-INF/**</warSourceExcludes>-->
						
						<!-- 表示在打war包时过滤位于src/main/resources目录中指定的目录或文件
						<packagingExcludes>*.*</packagingExcludes> -->
						
				        <!-- 配置将资源文件打到classes目录下的相关信息-->
						<webResources>
							<resource>
								<!-- 元配置文件的目录，相对于pom.xml文件的路径 -->  
								<directory>src/main/resources</directory>
				                <!-- 是否过滤文件，也就是是否启动auto-config的功能   -->
				                <filtering>true</filtering>  
				                <!-- 目标路径 -->  
				                <targetPath>WEB-INF/classes</targetPath>  
							</resource>
					 	</webResources>
					 </configuration>
				</plugin>
				<!-- 生成可执行的启动脚本： http://www.mojohaus.org/appassembler/appassembler-maven-plugin，http://blog.csdn.net/mn960mn/article/details/51554152 -->
				<plugin>
					<groupId>org.codehaus.mojo</groupId>
					<artifactId>appassembler-maven-plugin</artifactId>
					<executions>
						<execution>
							<id>make-assembly</id>
							<phase>package</phase>
							<goals>
								<goal>assemble</goal>
							</goals>
						</execution>
						<execution>
							<id>make-daemons</id>
							<phase>package</phase>
							<goals>
								<goal>generate-daemons</goal>
							</goals>
						</execution>
					</executions>
					<configuration>

						<!-- 脚本模式、进程模式 通用参数 -->

						<!-- 配置文件的目标目录 -->
						<configurationDirectory>conf</configurationDirectory>
						<!-- 从哪里拷贝配置文件 (默认src/main/config) <configurationSourceDirectory>${project.build.directory}/antrun/generated-resources</configurationSourceDirectory> -->
						<!-- 是否拷贝配置文件到上面的目录中;因为Spring-Boot资源不需要全部拷贝，这里交由antrun插件帮我们部分进行拷贝 -->
						<copyConfigurationDirectory>false</copyConfigurationDirectory>

						<!-- 过滤源配置目录时应用的字符编码格式 -->
						<encoding>UTF-8</encoding>
						<!-- $BASEDIR/bin目录中的启动脚本执行前调用的脚本名称，用于设置环境变量，类似Tomcat的setenv。 注意：仅适用于jsw平台。如果这个可选的环境文件也设置了WRAPPER_CONF_OVERRIDES变量，它将被传递给JSW本机启动器的命令行参数， 
							以覆盖wrapper.conf的属性。有关详细信息，请参阅http://wrapper.tanukisoftware.com/doc/english/props-command-line.html。 -->
						<environmentSetupFileName>setenv</environmentSetupFileName>
						<!-- 此字符串前面的表达式将不会被更改。 如 \${foo}将被${foo}替换。 -->
						<escapeString>#</escapeString>
						<!-- 是否源配置目录应该被复制到配置的配置目录中。此配置可以由更通用的preAssembleDirectory选项替换 -->
						<filterConfigurationDirectory>true</filterConfigurationDirectory>
						<!-- 是否源预装配时复制到配置的目录应过滤assembleDirectory。 -->
						<filterPreAssembleDirectory>true</filterPreAssembleDirectory>
						<!-- 是否拷贝Maven依赖jar;因为Spring-Boot已经将依赖的jar打包到最终工程，这里指定不需要拷贝 -->
						<generateRepository>false</generateRepository>
						<!-- 您可以定义一个许可证头文件，该文件将替代生成的脚本中的默认头文件。 <licenseHeaderFile></licenseHeaderFile> -->
						<!-- 项目的日志目录。如果为此参数指定一个值，将创建一个名为给定的空目录 -->
						<logsDirectory>logs</logsDirectory>
						<!-- 将库复制到存储库时使用的文件名映射。如果没有设置文件映射（默认），则使用其标准名称复制文件。注意：如果使用此参数，则将 忽略useTimestampInSnapshotFileName参数。 -->
						<!-- <outputFileNameMapping></outputFileNameMapping> -->
						<!-- 如果存在，请将此目录的内容复制到配置的 assembleDirectory，并使用选项进行过滤。此配置可以替代copyConfigurationDirectory 
							<preAssembleDirectory></preAssembleDirectory> -->
						<!-- 生成的Maven仓库的布局。支持的类型 - “默认”（Maven2）| “遗产”（Maven1）| “平”（flat lib 
							/ style）。 只有当您运行在Maven 2.2.1之前，才支持“legacy”样式。 说明： 如果拷贝Maven依赖jar;则对应的lib目录中jar的存放规则，默认是${groupId}/${artifactId}的目录格式，flat表示直接把jar放到lib目录 -->
						<repositoryLayout>flat</repositoryLayout>
						<!-- 打包的jar,以及maven依赖的jar存储的目录（相对于assembleDirectory） -->
						<repositoryName>lib</repositoryName>
						<!-- 项目的临时目录。如果为此参数指定一个值，将创建一个名为给定的空目录。 -->
						<tempDirectory>tmp</tempDirectory>
						<!-- 生成的脚本的unix模板。它可以是文件或资源路径。如果没有给出，使用内部的。小心使用，因为它不能保证与新的插件版本兼容。 -->
						<unixScriptTemplate></unixScriptTemplate>
						<!-- 对于从远程回购下载的快照，请使用“SNAPSHOT”替换时间戳部分。 -->
						<useTimestampInSnapshotFileName>false</useTimestampInSnapshotFileName>
						<!-- 有时候，有许多依赖关系意味着有一个非常长的类路径，并且变得太长（特别是在基于Windows的平台上）。这种选择可以帮助这种情况。 
							如果激活此选项，您的类路径只包含一个类路径通配符（REPO/*）。但请注意，这仅适用于Java 1.6及更高版本,且 repositoryLayout=flat的情况。 -->
						<useWildcardClassPath>true</useWildcardClassPath>
						<!-- 生成脚本的windows模板。它可以是文件或资源路径。如果没有给出，使用内部的。小心使用，因为它不能保证与新的插件版本兼容。 
							<windowsScriptTemplate></windowsScriptTemplate> -->

						<!-- 命令模式 : http://www.mojohaus.org/appassembler/appassembler-maven-plugin/assemble-mojo.html -->

						<!-- 将生成bin文件的一组程序配置（必填参数） -->
						<programs>
							<program>
								<id>zftal-boot</id>
								<!--指定主类，脚本名。会生成shell/bat两种类型,也可用platforms指定运行平台 -->
								<mainClass>org.springframework.boot.loader.JarLauncher</mainClass>
								<!-- 生成的脚本文件的名称，比如start.sh,你也可以根据你的需要命名成其他名字 -->
								<licenseHeaderFile></licenseHeaderFile>
								<jvmSettings>
									<extraArguments>
										<!-- 后台服务运行 -->
										<extraArgument>-server</extraArgument>
										<!-- 初始内存 -->
										<extraArgument>-Xms256M</extraArgument>
										<!-- 最小内存 -->
										<extraArgument>-Xmn512M</extraArgument>
										<!-- 最大内存 -->
										<extraArgument>-Xmx512M</extraArgument>
										<!-- 元空间 -->
										<!-- 初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。 -->
										<extraArgument>-XX:MetaspaceSize=256M</extraArgument>
										<!-- 最大空间，默认是没有限制的 -->
										<extraArgument>-XX:MaxMetaspaceSize=512M</extraArgument>
										<!-- 在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 <extraArgument>-XX:MinMetaspaceFreeRatio=60</extraArgument> -->
										<!-- 在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集 <extraArgument>-XX:MaxMetaspaceFreeRatio=60</extraArgument> -->
									</extraArguments>
								</jvmSettings>
							</program>
						</programs>

						<!-- 生成的执行脚本存放目录；默认${project.build.directory}/appassembler.（必填参数） -->
						<assembleDirectory>${project.build.directory}/generated-resources/appassembler/${project.artifactId}</assembleDirectory>
						<!-- 用于bin文件的文件扩展名。文件扩展名存储在使用平台名称作为键的地图中。要将Unix bin文件的文件扩展名更改为“.sh”，请使用此配置： -->
						<binFileExtensions>
							<unix>.sh</unix>
						</binFileExtensions>
						<!-- 可执行脚本的目录 -->
						<binFolder>bin</binFolder>
						<!-- 额外的JVM参数。如果在Program.setJvmSettings（） 级别上定义JvmSettings，则该部分将被程序级别的给定参数覆盖。 
							否则，如果没有给予Program.setJvmSettings（），将使用这些设置。 这可以用于定义一些默认值，而通过使用 Program.setJvmSettings（）覆盖默认设置。这仅适用于不是JvmSettings其余部分的extraJvmArguments。 
							自从1.2以来，可以使用BASEDIR @和@ REPO @的占位符 ，将根据将生成相应脚本的平台进行扩展。 http://www.cnblogs.com/paddix/p/5309550.html -->
						<extraJvmArguments>-Xms256M -Xmn512M -Xmx512M
							-XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=512M</extraJvmArguments>
						<!-- 是否显示控制台 -->
						<showConsoleWindow>true</showConsoleWindow>

						<!-- 插件将会为其生成bin文件的默认平台。使用字符串值进行配置 - “全部”（默认/空）| “windows”| “UNIX”。 -->
						<platforms>
							<platform>windows</platform>
							<platform>unix</platform>
						</platforms>
						<!-- 如果configurationDirectory（默认情况下）应包含在生成的bin文件的类路径的开始。（注意：该配置指定外部配置文件路径，如不配置可能导致无法启动） -->
						<includeConfigurationDirectoryInClasspath>true</includeConfigurationDirectoryInClasspath>
						<!-- 这可以用于将项目依赖、配置文件夹（等等）放置于类路径的第一个条目。默认行为是放在classpath的最后一个位置。 -->
						<projectArtifactFirstInClassPath>false</projectArtifactFirstInClassPath>
						<!-- 以下可用于使用所有项目依赖关系，而不是 仅代表运行时依赖关系的默认行为。 -->
						<useAllProjectDependencies>false</useAllProjectDependencies>

						<!-- 后台服务模式 : http://www.mojohaus.org/appassembler/appassembler-maven-plugin/generate-daemons-mojo.html -->

						<!-- 一套守护进程生成配置（必填参数） -->
						<daemons>
							<daemon>
								<!-- 唯一ID，会影响生成的目录名 -->
								<id>${project.artifactId}</id>
								<mainClass>org.springframework.boot.loader.JarLauncher</mainClass>
								<platforms>
									<platform>jsw</platform>
								</platforms>
								<generatorConfigurations>
									<generatorConfiguration>
										<generator>jsw</generator>
										<includes>
											<include>linux-x86-32</include>
											<include>linux-x86-64</include>
											<include>linux-ppc-64</include>
											<include>macosx-universal-32</include>
											<include>macosx-universal-64</include>
											<include>solaris-sparc-32</include>
											<include>solaris-sparc-64</include>
											<include>solaris-x86-32</include>
											<include>windows-x86-32</include>
											<include>windows-x86-64</include>
										</includes>
										<configuration>
											<property>
												<name>configuration.directory.in.classpath.first</name>
												<value>conf</value>
											</property>
											<property>
												<name>wrapper.ping.timeout</name>
												<value>120</value>
											</property>
											<property>
												<name>set.default.REPO_DIR</name>
												<value>lib</value>
											</property>
											<property>
												<name>wrapper.logfile</name>
												<value>logs/wrapper.log</value>
											</property>
										</configuration>
									</generatorConfiguration>
								</generatorConfigurations>
								<environmentSetupFileName></environmentSetupFileName>
								<jvmSettings>
									<extraArguments>
										<!-- 初始内存 -->
										<extraArgument>-Xmn256M</extraArgument>
										<!-- 最小内存 -->
										<extraArgument>-Xmn512M</extraArgument>
										<!-- 最大内存 -->
										<extraArgument>-Xmx512M</extraArgument>
										<!-- 元空间 -->
										<!-- 初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。 -->
										<extraArgument>-XX:MetaspaceSize=256M</extraArgument>
										<!-- 最大空间，默认是没有限制的 -->
										<extraArgument>-XX:MaxMetaspaceSize=512M</extraArgument>
										<!-- 在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 <extraArgument>-XX:MinMetaspaceFreeRatio=60</extraArgument> -->
										<!-- 在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集 <extraArgument>-XX:MaxMetaspaceFreeRatio=60</extraArgument> -->
									</extraArguments>
									<systemProperties>
										<systemProperty>java.security.policy=conf/policy.all</systemProperty>
										<systemProperty>com.sun.management.jmxremote</systemProperty>
										<systemProperty>com.sun.management.jmxremote.port=1984</systemProperty>
										<systemProperty>com.sun.management.jmxremote.authenticate=false</systemProperty>
										<systemProperty>com.sun.management.jmxremote.ssl=false</systemProperty>
									</systemProperties>
								</jvmSettings>
							</daemon>
						</daemons>
						<!-- 项目的基本目录,默认值为：${basedir}。 -->
						<basedir>${project.artifactId}</basedir>
						<!-- 可执行脚本的名称 -->
						<binFileName>zftal-boot</binFileName>
						<!-- 生成的守护程序的目标目录。默认值为：${project.build.directory}/generated-resources/appassembler。 -->
						<target>${project.build.directory}/generated-resources/appassembler</target>
						<!-- JvmSettings描述最小/最大内存和堆栈大小，系统属性和额外的参数。 -->
						<defaultJvmSettings>
							<!-- 初始内存 -->
							<initialMemorySize>256M</initialMemorySize>
							<!-- 最大内存 -->
							<maxMemorySize>512M</maxMemorySize>
						</defaultJvmSettings>
						<!-- 使用此选项覆盖当前内置的增量包二进制文件。您将需要将增量包版本解压缩到由此选项设置的已知位置。 <externalDeltaPackDirectory></externalDeltaPackDirectory> -->
						<!-- 使用此选项将已知文件的内容预插入到生成的包装器配置文件中。例如：$ include ../conf/another-wrapper.conf 
							User属性是：preWrapperConf。 <preWrapperConf></preWrapperConf> -->
						<!-- 启用时，名称包装器配置文件为wrapper - $ {daemon.id} .conf -->
						<useDaemonIdAsWrapperConfName>false</useDaemonIdAsWrapperConfName>
						<!-- 启用时，将包装器可执行文件前缀为$ {daemon.id}。否则，使用原始名称（即包装） -->
						<useDaemonIdAsWrapperExePrefixName>false</useDaemonIdAsWrapperExePrefixName>
					</configuration>
				</plugin>
				<!-- ant脚步执行插件 -->
				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-antrun-plugin</artifactId>
					<executions>
						<!-- 在Maven打包阶段进行初步的脚本处理：拷贝配置文件 -->
						<execution>
							<id>copy-resources</id>
							<phase>package</phase>
							<goals>
								<goal>run</goal>
							</goals>
							<configuration>
								<target>
									<echo message="antrun copy resources" />

									<!-- 处理脚本模式依赖资源 -->

									<!-- 步骤1、拷贝应用程序Jar文件 -->
									<copy
										file="${project.build.directory}/${project.build.finalName}.jar"
										todir="${appassembler-dir}/${project.artifactId}/lib" />
									<!-- 步骤2、拷贝配置文件文件 -->
									<!-- <copy file="${basedir}/src/main/resources/conf/application.properties"
										todir="${appassembler-dir}/${project.artifactId}/conf/config" /> -->
									<!-- <copy file="${basedir}/src/main/resources/application.yml"
										todir="${appassembler-dir}/${project.artifactId}/conf" /> -->
									<copy file="${basedir}/src/main/resources/license.auth"
										todir="${appassembler-dir}/${project.artifactId}/conf" />
									<!-- 步骤3、拷贝Java环境变量设置文件 -->
									<copy file="${basedir}/environment/setenv" todir="${appassembler-dir}/${project.artifactId}/bin" />
									<copy file="${basedir}/environment/setenv.bat" todir="${appassembler-dir}/${project.artifactId}/bin" />

									<!-- 处理服务模式依赖资源 -->

									<!-- 步骤1、拷贝应用程序Jar文件 -->
									<copy
										file="${project.build.directory}/${project.build.finalName}.jar"
										todir="${appassembler-jsw-dir}/${project.artifactId}/lib" />
									<!-- 步骤2、拷贝配置文件文件 -->
									<!-- <copy file="${basedir}/src/main/resources/conf/application.properties"
										todir="${appassembler-jsw-dir}/${project.artifactId}/conf/config" /> -->
									<!-- <copy file="${basedir}/src/main/resources/application.yml"
										todir="${appassembler-jsw-dir}/${project.artifactId}/conf" /> -->
									<copy file="${basedir}/src/main/resources/license.auth"
										todir="${appassembler-jsw-dir}/${project.artifactId}/conf" />
									<!-- 步骤3、拷贝Java环境变量设置文件 -->
									<copy file="${basedir}/environment/setenv"
										todir="${appassembler-jsw-dir}/${project.artifactId}/bin" />
									<copy file="${basedir}/environment/setenv.bat"
										todir="${appassembler-jsw-dir}/${project.artifactId}/bin" />

								</target>
							</configuration>
						</execution>
						<!-- 在Maven安装阶段进行进一步的脚本处理：生成相关启停脚本 -->
						<execution>
							<id>build-shell</id>
							<phase>install</phase>
							<goals>
								<goal>run</goal>
							</goals>
							<configuration>
								<target>
									<echo message="antrun build shell" />

									<!-- 处理脚本模式依赖资源 -->

									<!-- 步骤4、拷贝Java运行环境文件 <copy file="${basedir}/environment/jre-8u60-linux-x64.tar.gz" 
										todir="${appassembler-dir}/${project.artifactId}" /> -->
									<!-- 步骤5、拷贝应用程序服务运行脚本 -->
									<copy file="${basedir}/environment/${appassembler-app-name}"
										todir="${appassembler-dir}/${project.artifactId}" />
									<!-- 步骤7、创建备份文件夹 -->
									<mkdir
										dir="${appassembler-dir}/${project.artifactId}/update/backup" />
									<mkdir
										dir="${appassembler-dir}/${project.artifactId}/update/latest" />
									<!-- 步骤8、构建应用更新脚本 -->
									<delete
										file="${appassembler-dir}/${project.artifactId}/update/update.sh"></delete>
									<echo
										file="${appassembler-dir}/${project.artifactId}/update/update.sh"
										append="true"
										message="service ${appassembler-app-name} stop${line.separator}"></echo>
									<echo
										file="${appassembler-dir}/${project.artifactId}/update/update.sh"
										append="true" message="rm -rf backup/lib/*.jar${line.separator}"></echo>
									<echo
										file="${appassembler-dir}/${project.artifactId}/update/update.sh"
										append="true" message="rm -rf backup/plugins/*.jar${line.separator}"></echo>
									<echo
										file="${appassembler-dir}/${project.artifactId}/update/update.sh"
										append="true" message="rm -rf backup/conf/*${line.separator}"></echo>
									<echo
										file="${appassembler-dir}/${project.artifactId}/update/update.sh"
										append="true" message="mv ../lib/*.jar backup/lib${line.separator}"></echo>
									<echo
										file="${appassembler-dir}/${project.artifactId}/update/update.sh"
										append="true" message="mv ../plugins/*.jar backup/plugins${line.separator}"></echo>
									<echo
										file="${appassembler-dir}/${project.artifactId}/update/update.sh"
										append="true" message="mv ../conf/* backup/conf${line.separator}"></echo>
									<echo
										file="${appassembler-dir}/${project.artifactId}/update/update.sh"
										append="true" message="cp latest/lib/*.jar ../lib${line.separator}"></echo>
									<echo
										file="${appassembler-dir}/${project.artifactId}/update/update.sh"
										append="true" message="cp latest/plugins/*.jar ../plugins${line.separator}"></echo>
									<echo
										file="${appassembler-dir}/${project.artifactId}/update/update.sh"
										append="true" message="cp latest/conf/* ../conf${line.separator}"></echo>
									<echo
										file="${appassembler-dir}/${project.artifactId}/update/update.sh"
										append="true"
										message="service ${appassembler-app-name} start${line.separator}"></echo>
									<!-- 步骤9、构建应用安装脚本 -->
									<delete file="${appassembler-dir}/${project.artifactId}/install.sh"></delete>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true" message="#!/bin/sh${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true"
										message="#解压独立jre运行包【如果希望工程使用独有的jdk、jre请将压缩包放置在项目根目录并修改下面的配置】${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true" message="#rm -rf jre1.8.0_60${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true" message="#tar -zxvf jre-8u60-linux-x64.tar.gz${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true" message="#File Authorized${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true" message="#chmod 755 jre1.8.0_60/bin/*${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true" message="chmod 755 bin/*${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true" message="chmod 755 ${appassembler-app-name}${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true" message="chmod 755 update/update.sh${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true" message="chmod 755 uninstall.sh${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true" message="#启停脚本服务化软连接${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true"
										message="rm -rf /etc/init.d/${appassembler-app-name}${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true"
										message="cp ./${appassembler-app-name} /etc/init.d/${appassembler-app-name}${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true"
										message="chkconfig --add ${appassembler-app-name}${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/install.sh"
										append="true"
										message="chkconfig --level 345 ${appassembler-app-name} on${line.separator}"></echo>
									<!-- 步骤9、构建应用卸载脚本 -->
									<delete
										file="${appassembler-dir}/${project.artifactId}/uninstall.sh"></delete>
									<echo file="${appassembler-dir}/${project.artifactId}/uninstall.sh"
										append="true" message="#!/bin/sh${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/uninstall.sh"
										append="true"
										message="chkconfig ${appassembler-app-name} off${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/uninstall.sh"
										append="true"
										message="chkconfig --del ${appassembler-app-name}${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/uninstall.sh"
										append="true"
										message="rm -rf /etc/init.d/${appassembler-app-name}${line.separator}"></echo>
									<echo file="${appassembler-dir}/${project.artifactId}/uninstall.sh"
										append="true" message="#rm -rf jre1.8.0_60${line.separator}"></echo>

									<!-- 处理服务模式依赖资源 -->

									<!-- 步骤4、拷贝Java运行环境文件 <copy file="${basedir}/environment/jre-8u60-linux-x64.tar.gz" 
										todir="${appassembler-jsw-dir}/${project.artifactId}" /> -->
									<!-- 步骤5、拷贝应用程序服务运行脚本 -->
									<copy file="${basedir}/environment/${appassembler-app-name}"
										todir="${appassembler-jsw-dir}/${project.artifactId}" />
									<!-- 步骤7、创建备份文件夹 -->
									<mkdir
										dir="${appassembler-jsw-dir}/${project.artifactId}/update/backup" />
									<mkdir
										dir="${appassembler-jsw-dir}/${project.artifactId}/update/latest" />
									<!-- 步骤8、构建应用更新脚本 -->
									<delete
										file="${appassembler-jsw-dir}/${project.artifactId}/update/update.sh"></delete>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/update/update.sh"
										append="true"
										message="service ${appassembler-app-name} stop${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/update/update.sh"
										append="true" message="rm -rf backup/lib/*.jar${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/update/update.sh"
										append="true" message="rm -rf backup/plugins/*.jar${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/update/update.sh"
										append="true" message="rm -rf backup/conf/*${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/update/update.sh"
										append="true" message="mv ../lib/*.jar backup/lib${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/update/update.sh"
										append="true" message="mv ../plugins/*.jar backup/plugins${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/update/update.sh"
										append="true" message="mv ../conf/* backup/conf${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/update/update.sh"
										append="true" message="cp latest/lib/*.jar ../lib${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/update/update.sh"
										append="true" message="cp latest/plugins/*.jar ../plugins${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/update/update.sh"
										append="true" message="cp latest/conf/* ../conf${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/update/update.sh"
										append="true"
										message="service ${appassembler-app-name} start${line.separator}"></echo>
									<!-- 步骤9、构建应用安装脚本 -->
									<delete
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"></delete>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true" message="#!/bin/sh${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true"
										message="#解压独立jre运行包【如果希望工程使用独有的jdk、jre请将压缩包放置在项目根目录并修改下面的配置】${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true" message="#rm -rf jre1.8.0_60${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true" message="#tar -zxvf jre-8u60-linux-x64.tar.gz${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true" message="#File Authorized${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true" message="#chmod 755 jre1.8.0_60/bin/*${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true" message="chmod 755 bin/*${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true" message="chmod 755 ./${appassembler-app-name}${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true" message="chmod 755 update/update.sh${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true" message="chmod 755 uninstall.sh${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true" message="#启停脚本服务化软连接${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true"
										message="rm -rf /etc/init.d/${appassembler-app-name}${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true"
										message="cp ./${appassembler-app-name} /etc/init.d/${appassembler-app-name}${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true"
										message="chkconfig --add ${appassembler-app-name}${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/install.sh"
										append="true"
										message="chkconfig --level 345 ${appassembler-app-name} on${line.separator}"></echo>
									<!-- 步骤9、构建应用卸载脚本 -->
									<delete
										file="${appassembler-jsw-dir}/${project.artifactId}/uninstall.sh"></delete>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/uninstall.sh"
										append="true" message="#!/bin/sh${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/uninstall.sh"
										append="true"
										message="chkconfig ${appassembler-app-name} off${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/uninstall.sh"
										append="true"
										message="chkconfig --del ${appassembler-app-name}${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/uninstall.sh"
										append="true"
										message="rm -rf /etc/init.d/${appassembler-app-name}${line.separator}"></echo>
									<echo
										file="${appassembler-jsw-dir}/${project.artifactId}/uninstall.sh"
										append="true" message="#rm -rf jre1.8.0_60${line.separator}"></echo>
								</target>
							</configuration>
						</execution>
					</executions>
				</plugin>
				<!-- docker-maven插件: https://github.com/spotify/docker-maven-plugin,http://blog.csdn.net/qq_22841811/article/details/67369530 -->
				<plugin>
					<groupId>com.spotify</groupId>
					<artifactId>docker-maven-plugin</artifactId>
					<version>0.4.13</version>
					<executions>
						<!-- <execution>
							<id>build-image</id>
							<phase>package</phase>
							<goals>
								<goal>build</goal>
							</goals>
						</execution> -->
						<!-- <execution>
							<id>tag-image</id>
							<phase>package</phase>
							<goals>
								<goal>tag</goal>
							</goals>
							<configuration>
								<image>${project.artifactId}:${project.version}</image>
								<newName>${docker.push.repostory}:8798/${docker.registry.name}/${project.artifactId}:${project.version}</newName>
							</configuration>
						</execution> -->
						<!-- <execution>
							<id>push-image</id>
							<phase>deploy</phase>
							<goals>
								<goal>push</goal>
							</goals>
							<configuration>
								<imageName>${docker.push.repostory}:8798/${docker.registry.name}/${project.artifactId}:${project.version}</imageName>
							</configuration>
						</execution> -->
					</executions>
					<configuration>
						<!-- 注意imageName一定要是符合正则[a-z0-9-_.]的，否则构建不会成功 -->
						<!-- 详见：https://github.com/spotify/docker-maven-plugin Invalid repository 
							name ... only [a-z0-9-_.] are allowed -->
						<!-- 如果要将docker镜像push到DockerHub上去的话，这边的路径要和repo路径一致 -->
						<!-- <imageName>${project.artifactId}:${project.version}</imageName> -->
						<imageName>${docker.push.repostory}/${docker.registry.name}/${project.artifactId}:${project.version}</imageName>
						<!-- 指定Dockerfile所在的路径 -->
						<!-- <dockerDirectory>${project.basedir}/src/main/docker</dockerDirectory> -->
						<baseImage>jdk:1.8</baseImage>
						<workdir>${docker.workdir}</workdir>
						<entryPoint>["sh","./bin/zftal-boot.sh"]</entryPoint>
						<dockerHost>http://${docker.build.repostory}:2376</dockerHost>
						<resources>
							<resource>
								<targetPath>${docker.workdir}</targetPath>
								<directory>${appassembler-dir}/${project.artifactId}</directory>
							</resource>
						</resources>
						<!-- 以下两行是为了docker push到DockerHub使用的。 -->
						<serverId>docker-hub</serverId>
						<registryUrl>http://${docker.push.repostory}/</registryUrl>
					</configuration>
				</plugin>
				<!-- 
					https://github.com/Swagger2Markup/swagger2markup-maven-project-template/blob/master/pom.xml
				 -->
				<!-- First, use the swagger2markup plugin to generate asciidoc -->
			    <plugin>
			        <groupId>io.github.swagger2markup</groupId>
			        <artifactId>swagger2markup-maven-plugin</artifactId>
			        <dependencies>
						<dependency>
						    <groupId>io.github.swagger2markup</groupId>
						    <artifactId>swagger2markup-import-schemas-ext</artifactId>
						    <version>${swagger2markup.extension.version}</version>
						</dependency>
						<dependency>
						    <groupId>io.github.swagger2markup</groupId>
						    <artifactId>swagger2markup-import-files-ext</artifactId>
						    <version>${swagger2markup.extension.version}</version>
						</dependency>
	                    <dependency>
						    <groupId>io.github.swagger2markup</groupId>
						    <artifactId>swagger2markup-spring-restdocs-ext</artifactId>
						    <version>${swagger2markup.extension.version}</version>
						</dependency>
					</dependencies>
			        <configuration>
			            <swaggerInput>${swagger.input}</swaggerInput>
			            <outputDir>${generated.asciidoc.directory}</outputDir>
			            <config>
	                        <swagger2markup.markupLanguage>ASCIIDOC</swagger2markup.markupLanguage>
	                        <swagger2markup.pathsGroupedBy>TAGS</swagger2markup.pathsGroupedBy>
	                        <swagger2markup.extensions.dynamicOverview.contentPath>${project.basedir}/src/docs/asciidoc/extensions/overview</swagger2markup.extensions.dynamicOverview.contentPath>
	                        <swagger2markup.extensions.dynamicDefinitions.contentPath>${project.basedir}/src/docs/asciidoc/extensions/definitions</swagger2markup.extensions.dynamicDefinitions.contentPath>
	                        <swagger2markup.extensions.dynamicPaths.contentPath>${project.basedir}/src/docs/asciidoc/extensions/paths</swagger2markup.extensions.dynamicPaths.contentPath>
	                        <swagger2markup.extensions.dynamicSecurity.contentPath>${project.basedir}src/docs/asciidoc/extensions/security</swagger2markup.extensions.dynamicSecurity.contentPath>
							<swagger2markup.extensions.springRestDocs.snippetBaseUri>${swagger.snippetOutput.dir}</swagger2markup.extensions.springRestDocs.snippetBaseUri>
							<swagger2markup.extensions.springRestDocs.defaultSnippets>true</swagger2markup.extensions.springRestDocs.defaultSnippets>
						</config>
			        </configuration>
			        <executions>
	                    <execution>
	                        <phase>package</phase>
	                        <goals>
	                            <goal>convertSwagger2markup</goal>
	                        </goals>
	                    </execution>
					</executions>
			    </plugin>
			    <!-- Run the generated asciidoc through Asciidoctor to generate
	                 other documentation types, such as PDFs or HTML5 -->
		        <plugin>
		        	<groupId>org.asciidoctor</groupId>
		        	<artifactId>asciidoctor-maven-plugin</artifactId>
		        	<!-- Include Asciidoctor PDF for pdf generation -->
		        	<dependencies>
	                    <dependency>
	                        <groupId>org.asciidoctor</groupId>
	                        <artifactId>asciidoctorj-pdf</artifactId>
	                        <version>${asciidoctorj.pdf.version}</version>
	                    </dependency>
	                    <!-- Comment this section to use the default jruby artifact provided by the plugin -->
	                    <dependency>
	                        <groupId>org.jruby</groupId>
	                        <artifactId>jruby-complete</artifactId>
	                        <version>${jruby.version}</version>
	                    </dependency>
	                    <!-- Comment this section to use the default AsciidoctorJ artifact provided by the plugin -->
	                    <dependency>
	                        <groupId>org.asciidoctor</groupId>
	                        <artifactId>asciidoctorj</artifactId>
	                        <version>${asciidoctorj.version}</version>
	                    </dependency>
					</dependencies>
					<!-- Configure generic document generation settings -->
	          		<configuration>
	                    <sourceDirectory>${asciidoctor.input.directory}</sourceDirectory>
	                    <!-- <sourceDocumentName>index.adoc</sourceDocumentName> -->
	                    <attributes>
	                        <doctype>book</doctype>
	                        <toc>left</toc>
	                        <toclevels>3</toclevels>
	                        <numbered></numbered>
	                        <hardbreaks></hardbreaks>
	                        <sectlinks></sectlinks>
	                        <sectanchors></sectanchors>
	                        <generated>${generated.asciidoc.directory}</generated>
	                    </attributes>
					</configuration>
					<!-- Since each execution can only handle one backend, run
	                     separate executions for each desired output type -->
	          		<executions>
	                    <execution>
	                        <id>output-html</id>
	                        <phase>package</phase><!-- generate-resources -->
	                        <goals>
	                            <goal>process-asciidoc</goal>
	                        </goals>
	                        <configuration>
	                            <backend>html5</backend>
	                            <outputDirectory>${asciidoctor.html.output.directory}</outputDirectory>
	                        </configuration>
	                    </execution>
					</executions>
	    		</plugin> 
				
				<!-- sonar插件 -->
				<plugin>
					<groupId>org.codehaus.sonar</groupId>
					<artifactId>sonar-maven-plugin</artifactId>
					<version>5.1</version>
				</plugin>
				<!-- 单元测试代码覆盖率插件 -->
				<plugin>
					<groupId>org.codehaus.mojo</groupId>
					<artifactId>cobertura-maven-plugin</artifactId>
					<version>2.6</version>
	
					<configuration>
						<!--这个标签一般不在这配置,一般跟着命令后面作为参数使用 -->
						<!--<format>xml</format> -->
						<formats>
							<format>xml</format>
							<format>html</format>
						</formats>
					</configuration>
					<dependencies>
						<dependency>
							<groupId>org.ow2.asm</groupId>
							<artifactId>asm</artifactId>
							<version>5.0.3</version>
						</dependency>
					</dependencies>
				</plugin>
			</plugins>
		</pluginManagement>
		<plugins>
			<!-- 资源插件：复制主资源文件至主输出目录 -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-resources-plugin</artifactId>
			</plugin>
			<!-- 编译插件：编译主代码至主输出目录 -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
			</plugin>
			<!-- 单元测试插件 ：执行测试用例 -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
			</plugin>
			<!-- jar包生成插件 ：创建项目jar包 -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-jar-plugin</artifactId>
			</plugin>
			<!-- 安装插件：将项目输出构件安装到本地仓库 -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-install-plugin</artifactId>
			</plugin>
			<!-- 发布插件 ：将项目输出构件部署到远程仓库 -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-deploy-plugin</artifactId>
			</plugin>
			<!-- 源码插件:发布时自动将源码同时发布 -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-source-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>
